虚函数： 在某基类中声明为 virtual 并在一个或多个派生类中被重新定义的成员函数，可实现函数成员的动态重载。  
`virtual <类型> <函数名> (<参数表>) {函数体};`

纯虚函数： 纯虚函数是一种特殊的虚函数，在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。含有纯虚函数的类被称为抽象类(abstract class)  
`virtual <类型> <函数名> (<参数表>) = 0;`

### 引入虚函数
当没有引入虚函数时，一个空类的大小为1。在类中写入虚函数时，会自动创建一个潜在的虚函数表指针(virtual pointer)，该指针占用四个字节，指向一个虚函数表(virtual function table)。

``` cpp
class A{
public:
  void function1();
  void function2();
  virtual void function3();
  virtual void function 4();
  virtual ~A();
private:
  int m_a;
}
```
类A的内存布局是： vptr 和 m_a。

vptr指向vtbl，vtbl里面有三个指针，分别指向各自的虚函数(function3, function4, ~A)。

虚函数表和虚函数以及普通函数是类A的组成部分，但不占用类A的空间。此时`sizeof(A)`的结果是 4(虚函数指针) + 4(int a) = 8.(x86平台)

### 在类中的应用

基类中有虚函数，子类中有(虚)函数，并且重写该函数，通过一个**基类指针new一个子类对象**，使用该指针的时候，**子类的这个(虚)函数**则被调用。

delete也是，如果delete该指针，那么要在基类的析构函数中标记为虚函数，否则delete是不运行子类的析构函数。**如果基类析构函数为虚函数，那么delete该指针时，会先调用子类的析构函数，后调用基类的析构函数。**

如果不加virtual关键词，那么该情况下，该基类指针时不可以访问子类的重写(覆盖/override)函数的。

子类对象的虚函数表和基类对象的两个虚函数表中，里面的虚函数地址是一样的，如果在子类中重写了某个虚函数，那么该地址则不一样。

### 普通成员函数和析构函数加virtual

如果是基类中的普通成员函数，那么加入virtual，可以**跳过**基类中的虚函数，反而执行派生类中的重写后的函数。如果是虚构函数，它比较特殊，它加入virtual修饰后，自动在派生类中**重写一遍**。所以先执行派生类的析构函数，再执行基类的析构函数。

