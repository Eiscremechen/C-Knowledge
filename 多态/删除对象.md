###
B类和D类定义见[构造函数和析构函数的调用顺序](https://zhuanlan.zhihu.com/p/371322392)

例子：
#### 无delete
``` c++
int main() {
	B b = D();
	cout << "" << endl;
	return 0;
}
// B0::B()
// D0::D()
// B2::B()
// ~D() d
// ~B() d
// 
// ~B() b
```
在这个示例中，你创建了一个 `B` 类型的对象 `b` 并用 `D()` 的匿名对象进行初始化。这不涉及指针或动态内存分配，因此没有 `delete` 操作，因此也不会涉及析构函数的调用问题。

当你执行 `B b = D();` 时，会发生以下步骤：

1. 创建了一个匿名对象 `D()`，这个对象首先调用 `B` 的构造函数（因为 `D` 是 `B` 的派生类）。
2. 然后，匿名对象被复制给了 `b`，这里涉及到了对象拷贝构造函数。
3. 当 `b` 超出作用域时，它会调用其析构函数。

请注意，这里不需要手动删除对象或指针，因为对象的生命周期是由其作用域管理的。匿名对象的生命周期仅限于此语句，所以它的析构函数会在此语句结束后被调用。

总之，这个示例不会引发上面提到的基类和派生类的析构函数的问题，因为它没有涉及动态内存分配或指针。

#### 有delete
``` c++
int main() {
  B* d = new D;    //先调用B()，再调用D()
  delete d;
  return 0;
}
// B0::B()
// D0::D()
// ~B() // 注意：此行代码会调用~B()，但不会调用~D()，因为基类的析构函数未加上virtual，造成内存泄漏

// 注意：如果基类的析构函数加上virtual，则delete时基类和子类都会被释放：
// B0::B()
// D0::D()
// ~D()
// ~B() 
```

解释：
在C++中，当你删除一个基类指针，只会调用基类的析构函数，而不会自动调用派生类的析构函数。这是因为派生类的析构函数可能包含与派生类特有的资源管理相关的操作，这些操作在基类的析构函数中无法处理。

### 加入虚函数
```
class B {
public:
    B() { std::cout << "B constructor" << std::endl; }
    virtual ~B() { std::cout << "B destructor" << std::endl; }
};

class D : public B {
public:
    D() { std::cout << "D constructor" << std::endl; }
    ~D() { std::cout << "D destructor" << std::endl; }
};

int main() {
    B* ptr = new D;
    delete ptr;
    return 0;
}
```
在这个示例中，我们创建了一个基类指针 ptr，指向一个派生类对象 D。当我们使用 delete ptr 删除这个对象时，只会调用基类 B 的析构函数。这是因为基类指针无法知道它指向的是派生类对象，因此只会调用基类的析构函数。

如果你希望在删除基类指针时同时调用派生类的析构函数，你需要将基类的析构函数声明为虚函数，如上面示例中所做的那样。这将允许在运行时根据实际对象类型调用适当的析构函数，确保正确地释放所有资源。

* 如果不加virtual，会按指针的类类型进行析构，也就是基类。delete时只释放基类，不释放子类；
* 如果加了virtual，会按指向类型进行析构，也就是子类。 然后析构子类的话会默认析构基类，delete时基类和子类都会被释放；
* 所以不加virtual可能会存在内存泄露的问题
